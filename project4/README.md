sm3.py中实现了sm3算法，SM3 采用 Merkle-Damgård 结构（类似 SHA-1/SHA-2），消息分组：512 位（64 字节）分组。填充方式：类似 SHA-2，采用 PKCS#5/PKCS#7 风格的填充。轮函数：64 轮非线性运算，结合 布尔运算、模加、移位 等操作。核心组件包括rotate_left: 32位循环左移操作。FF和GG: 布尔函数。P0和P1: 置换函数。padding: 消息填充函数。message_expansion: 消息扩展函数。compress_function: 压缩函数。
SM3_Optimized.py对算法进行了性能上的优化。通过减少函数调用开销，使用位运算优化，预计算常量，减少临时对象创建提升性能。将辅助函数改为类方法，减少调用开销，在压缩函数中展开部分循环。使用struct模块进行快速字节转换，优化循环位移操作。使用bytearray预分配填充消息空间，减少临时对象的创建。将压缩函数的循环部分展开，分离前16轮和后48轮的处理，性能提升了1.08倍
SM3_LEA.py为基于sm3的实现，验证length-extension attack，攻击条件:知道原始消息的哈希值，知道原始消息的长度，不知道原始消息的内容。攻击步骤:根据原始长度生成正确的填充数据，将原始哈希值作为初始向量(IV)，对扩展消息(包括必要的填充)计算哈希。结果验证:攻击生成的哈希值应该与hash(secret || original || padding || extension)相同，即使不知道原始消息内容也能生成有效哈希。
SM3_mer.py基于sm3的实现，根据RFC6962构建Merkle树（10w叶子节点），并构建叶子的存在性证明和不存在性证明,生成证明：从叶子节点到根节点的路径上所有兄弟节点的哈希,按照从下到上的顺序排列,验证证明：从叶子哈希开始，依次与证明中的兄弟节点哈希组合计算,最终结果应与Merkle根一致.不存在性证生成证明：找到目标叶子应该位于的两个相邻节点（前驱和后继）,提供这两个节点的存在性证明.验证证明：验证前驱节点确实小于目标叶子,验证后继节点确实大于目标叶子,验证这两个节点在树中是连续的.
